"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSpecificationEvolution = void 0;
/* eslint-disable no-console */
const child_process = require("child_process");
const fs = require("fs-extra");
const SKIP_FILE = 'skip-evolution-check.txt';
/**
 * Run validations on the spec evolution, on the pull request.
 *
 * First `git checkout`s the old commit, builds the spec, does the
 * same for the new commit, then runs comparisons on the both.
 *
 * Expects and uses git.
 */
async function validateSpecificationEvolution(specProducer) {
    const prNumber = (process.env.CODEBUILD_WEBHOOK_TRIGGER ?? '').replace(/^pr\//, '');
    const skips = (await fs.readFile(SKIP_FILE, { encoding: 'utf-8' })).split('\n');
    if (prNumber && skips.includes(prNumber)) {
        console.log(`Skipping evo check of PR ${prNumber} (${SKIP_FILE})`);
        await specProducer();
        return;
    }
    const targetBranch = process.env.CODEBUILD_WEBHOOK_BASE_REF ?? 'main';
    console.log(`Comparing differences with ${targetBranch}`);
    const mergeBase = child_process.execSync(`git merge-base ${targetBranch} HEAD`).toString().trim();
    console.log(`Base commit ${mergeBase}`);
    // Find branch name if we have one
    let currentCommit = child_process.execSync('git rev-parse --abbrev-ref HEAD').toString().trim();
    if (currentCommit === 'HEAD') {
        // No branch, just spec use commit
        currentCommit = child_process.execSync('git rev-parse HEAD').toString().trim();
    }
    console.log(`Current commit ${currentCommit}`);
    const specs = new Array();
    for (const commit of [mergeBase, currentCommit]) {
        process.stdout.write([
            '┌───────────────────────────────────────────────────────────────────────────────────',
            `│   Doing spec build at commit: ${commit}`,
            '└─▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄',
        ].join('\n') + '\n');
        child_process.execSync(`git checkout ${commit}`);
        specs.push(await specProducer());
    }
    validatePropertyTypeNameConsistency(specs[0], specs[1]);
}
exports.validateSpecificationEvolution = validateSpecificationEvolution;
/**
 * Safeguard check: make sure that all old property type names in the old spec exist in the new spec
 *
 * If not, it's probably because the service team renamed a type between spec
 * version `v(N)` to `v(N+1)`. In the CloudFormation spec itself, this is not a
 * problem. However, CDK will have generated actual classes and interfaces with
 * the type names at `v(N)`, which people will have written code against. If the
 * classes and interfaces would have a new name at `v(N+1)`, all user code would
 * break.
 */
function validatePropertyTypeNameConsistency(oldSpec, newSpec) {
    const newPropsTypes = newSpec.PropertyTypes ?? {};
    const disappearedKeys = Object.keys(oldSpec.PropertyTypes ?? {}).filter(k => !(k in newPropsTypes));
    if (disappearedKeys.length === 0) {
        return;
    }
    const operations = [];
    for (const key of disappearedKeys) {
        const [cfnResource, typeName] = key.split('.');
        const usages = findTypeUsages(oldSpec, cfnResource, typeName);
        if (usages.length === 0) {
            // Might have disappeared, but no one should have been using this
            continue;
        }
        operations.push({
            op: 'move',
            from: `/PropertyTypes/${cfnResource}.<NEW_TYPE_NAME_HERE>`,
            path: `/PropertyTypes/${cfnResource}.${typeName}`,
        });
        operations.push(...usages.map((path) => ({
            op: 'replace',
            path,
            value: typeName,
        })));
    }
    const exampleJsonPatch = {
        patch: {
            description: 'Undoing upstream property type renames of <SERVICE> because <REASON>',
            operations,
        },
    };
    const now = new Date();
    const YYYY = `${now.getFullYear()}`;
    const MM = `0${now.getMonth() + 1}`.slice(-2);
    const DD = `0${now.getDate()}`.slice(-2);
    process.stderr.write([
        '┌───────────────────────────────────────────────────────────────────────────────────────┐',
        '│                                                                                       ▐█',
        '│  PROPERTY TYPES HAVE DISAPPEARED                                                      ▐█',
        '│                                                                                       ▐█',
        '│  Some type names have disappeared from the old specification.                         ▐█',
        '│                                                                                       ▐█',
        '│  This probably indicates that the service team renamed one of the types. We have      ▐█',
        '│  to keep the old type names though: renaming them would constitute a breaking change  ▐█',
        '│  to consumers of the L1 resources.                                                    ▐█',
        '│                                                                                       ▐█',
        '└─▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▟█',
        '',
        'See what the renames were, check out this PR locally and add a JSON patch file for these types:',
        '',
        `(Example 600_Renames_${YYYY}${MM}${DD}_patch.json)`,
        '',
        JSON.stringify(exampleJsonPatch, undefined, 2),
        '\n',
    ].join('\n'));
    process.exitCode = 1;
}
function findTypeUsages(spec, cfnResource, typeName) {
    const ret = new Array();
    const typesToInspect = [
        ...Object.keys(spec.PropertyTypes ?? {})
            .filter((propTypeName) => propTypeName.startsWith(`${cfnResource}.`))
            .map((propTypeName) => ['PropertyTypes', propTypeName]),
        ...spec.ResourceTypes?.[cfnResource] ? [['ResourceTypes', cfnResource]] : [],
    ];
    for (const [topKey, typeKey] of typesToInspect) {
        const propType = spec[topKey][typeKey];
        for (const innerKey of ['Properties', 'Attributes']) {
            for (const [propName, propDef] of Object.entries(propType?.[innerKey] ?? {})) {
                for (const [fieldName, fieldType] of Object.entries(propDef)) {
                    if (fieldType === typeName) {
                        ret.push(`/${topKey}/${typeKey}/${innerKey}/${propName}/${fieldName}`);
                    }
                }
            }
        }
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUtZXZvbHV0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidmFsaWRhdGUtZXZvbHV0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUMvQiwrQ0FBK0M7QUFDL0MsK0JBQStCO0FBRS9CLE1BQU0sU0FBUyxHQUFHLDBCQUEwQixDQUFDO0FBRTdDOzs7Ozs7O0dBT0c7QUFDSSxLQUFLLFVBQVUsOEJBQThCLENBQUMsWUFBZ0M7SUFDbkYsTUFBTSxRQUFRLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUF5QixJQUFJLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDcEYsTUFBTSxLQUFLLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEYsSUFBSSxRQUFRLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRTtRQUN4QyxPQUFPLENBQUMsR0FBRyxDQUFDLDRCQUE0QixRQUFRLEtBQUssU0FBUyxHQUFHLENBQUMsQ0FBQztRQUNuRSxNQUFNLFlBQVksRUFBRSxDQUFDO1FBQ3JCLE9BQU87S0FDUjtJQUVELE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsMEJBQTBCLElBQUksTUFBTSxDQUFDO0lBQ3RFLE9BQU8sQ0FBQyxHQUFHLENBQUMsOEJBQThCLFlBQVksRUFBRSxDQUFDLENBQUM7SUFDMUQsTUFBTSxTQUFTLEdBQUcsYUFBYSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsWUFBWSxPQUFPLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNsRyxPQUFPLENBQUMsR0FBRyxDQUFDLGVBQWUsU0FBUyxFQUFFLENBQUMsQ0FB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LGVBQWUsRUFBRSxZQUFZLENBQVUsQ0FBQztRQUNsRSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsRUFBRSxXQUFXLENBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO0tBQ3RGLENBQUM7SUFFRixLQUFLLE1BQU0sQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLElBQUksY0FBYyxFQUFFO1FBQzlDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV2QyxLQUFLLE1BQU0sUUFBUSxJQUFJLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQyxFQUFFO1lBRW5ELEtBQUssTUFBTSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFO2dCQUM1RSxLQUFLLE1BQU0sQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFjLENBQUMsRUFBRTtvQkFDbkUsSUFBSSxTQUFTLEtBQUssUUFBUSxFQUFFO3dCQUMxQixHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksTUFBTSxJQUFJLE9BQU8sSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLFNBQVMsRUFBRSxDQUFDLENBQUM7cUJBQ3hFO2lCQUNGO2FBQ0Y7U0FDRjtLQUNGO0lBRUQsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuaW1wb3J0ICogYXMgY2hpbGRfcHJvY2VzcyBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcblxuY29uc3QgU0tJUF9GSUxFID0gJ3NraXAtZXZvbHV0aW9uLWNoZWNrLnR4dCc7XG5cbi8qKlxuICogUnVuIHZhbGlkYXRpb25zIG9uIHRoZSBzcGVjIGV2b2x1dGlvbiwgb24gdGhlIHB1bGwgcmVxdWVzdC5cbiAqXG4gKiBGaXJzdCBgZ2l0IGNoZWNrb3V0YHMgdGhlIG9sZCBjb21taXQsIGJ1aWxkcyB0aGUgc3BlYywgZG9lcyB0aGVcbiAqIHNhbWUgZm9yIHRoZSBuZXcgY29tbWl0LCB0aGVuIHJ1bnMgY29tcGFyaXNvbnMgb24gdGhlIGJvdGguXG4gKlxuICogRXhwZWN0cyBhbmQgdXNlcyBnaXQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVNwZWNpZmljYXRpb25Fdm9sdXRpb24oc3BlY1Byb2R1Y2VyOiAoKSA9PiBQcm9taXNlPGFueT4pIHtcbiAgY29uc3QgcHJOdW1iZXIgPSAocHJvY2Vzcy5lbnYuQ09ERUJVSUxEX1dFQkhPT0tfVFJJR0dFUiA/PyAnJykucmVwbGFjZSgvXnByXFwvLywgJycpO1xuICBjb25zdCBza2lwcyA9IChhd2FpdCBmcy5yZWFkRmlsZShTS0lQX0ZJTEUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSkpLnNwbGl0KCdcXG4nKTtcbiAgaWYgKHByTnVtYmVyICYmIHNraXBzLmluY2x1ZGVzKHByTnVtYmVyKSkge1xuICAgIGNvbnNvbGUubG9nKGBTa2lwcGluZyBldm8gY2hlY2sgb2YgUFIgJHtwck51bWJlcn0gKCR7U0tJUF9GSUxFfSlgKTtcbiAgICBhd2FpdCBzcGVjUHJvZHVjZXIoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB0YXJnZXRCcmFuY2ggPSBwcm9jZXNzLmVudi5DT0RFQlVJTERfV0VCSE9PS19CQVNFX1JFRiA/PyAnbWFpbic7XG4gIGNvbnNvbGUubG9nKGBDb21wYXJpbmcgZGlmZmVyZW5jZXMgd2l0aCAke3RhcmdldEJyYW5jaH1gKTtcbiAgY29uc3QgbWVyZ2VCYXNlID0gY2hpbGRfcHJvY2Vzcy5leGVjU3luYyhgZ2l0IG1lcmdlLWJhc2UgJHt0YXJnZXRCcmFuY2h9IEhFQURgKS50b1N0cmluZygpLnRyaW0oKTtcbiAgY29uc29sZS5sb2coYEJhc2UgY29tbWl0ICR7bWVyZ2VCYXNlfWApO1xuICAvLyBGaW5kIGJyYW5jaCBuYW1lIGlmIHdlIGhhdmUgb25lXG4gIGxldCBjdXJyZW50Q29tbWl0ID0gY2hpbGRfcHJvY2Vzcy5leGVjU3luYygnZ2l0IHJldi1wYXJzZSAtLWFiYnJldi1yZWYgSEVBRCcpLnRvU3RyaW5nKCkudHJpbSgpO1xuICBpZiAoY3VycmVudENvbW1pdCA9PT0gJ0hFQUQnKSB7XG4gICAgLy8gTm8gYnJhbmNoLCBqdXN0IHNwZWMgdXNlIGNvbW1pdFxuICAgIGN1cnJlbnRDb21taXQgPSBjaGlsZF9wcm9jZXNzLmV4ZWNTeW5jKCdnaXQgcmV2LXBhcnNlIEhFQUQnKS50b1N0cmluZygpLnRyaW0oKTtcbiAgfVxuICBjb25zb2xlLmxvZyhgQ3VycmVudCBjb21taXQgJHtjdXJyZW50Q29tbWl0fWApO1xuXG4gIGNvbnN0IHNwZWNzID0gbmV3IEFycmF5PGFueT4oKTtcbiAgZm9yIChjb25zdCBjb21taXQgb2YgW21lcmdlQmFzZSwgY3VycmVudENvbW1pdF0pIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShbXG4gICAgICAn4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAJyxcbiAgICAgIGDilIIgICBEb2luZyBzcGVjIGJ1aWxkIGF0IGNvbW1pdDogJHtjb21taXR9YCxcbiAgICAgICfilJTilIDiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloQnLFxuICAgIF0uam9pbignXFxuJykgKyAnXFxuJyk7XG5cbiAgICBjaGlsZF9wcm9jZXNzLmV4ZWNTeW5jKGBnaXQgY2hlY2tvdXQgJHtjb21taXR9YCk7XG4gICAgc3BlY3MucHVzaChhd2FpdCBzcGVjUHJvZHVjZXIoKSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BlcnR5VHlwZU5hbWVDb25zaXN0ZW5jeShzcGVjc1swXSwgc3BlY3NbMV0pO1xufVxuXG4vKipcbiAqIFNhZmVndWFyZCBjaGVjazogbWFrZSBzdXJlIHRoYXQgYWxsIG9sZCBwcm9wZXJ0eSB0eXBlIG5hbWVzIGluIHRoZSBvbGQgc3BlYyBleGlzdCBpbiB0aGUgbmV3IHNwZWNcbiAqXG4gKiBJZiBub3QsIGl0J3MgcHJvYmFibHkgYmVjYXVzZSB0aGUgc2VydmljZSB0ZWFtIHJlbmFtZWQgYSB0eXBlIGJldHdlZW4gc3BlY1xuICogdmVyc2lvbiBgdihOKWAgdG8gYHYoTisxKWAuIEluIHRoZSBDbG91ZEZvcm1hdGlvbiBzcGVjIGl0c2VsZiwgdGhpcyBpcyBub3QgYVxuICogcHJvYmxlbS4gSG93ZXZlciwgQ0RLIHdpbGwgaGF2ZSBnZW5lcmF0ZWQgYWN0dWFsIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgd2l0aFxuICogdGhlIHR5cGUgbmFtZXMgYXQgYHYoTilgLCB3aGljaCBwZW9wbGUgd2lsbCBoYXZlIHdyaXR0ZW4gY29kZSBhZ2FpbnN0LiBJZiB0aGVcbiAqIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgd291bGQgaGF2ZSBhIG5ldyBuYW1lIGF0IGB2KE4rMSlgLCBhbGwgdXNlciBjb2RlIHdvdWxkXG4gKiBicmVhay5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eVR5cGVOYW1lQ29uc2lzdGVuY3kob2xkU3BlYzogYW55LCBuZXdTcGVjOiBhbnkpIHtcbiAgY29uc3QgbmV3UHJvcHNUeXBlcyA9IG5ld1NwZWMuUHJvcGVydHlUeXBlcyA/PyB7fTtcbiAgY29uc3QgZGlzYXBwZWFyZWRLZXlzID0gT2JqZWN0LmtleXMob2xkU3BlYy5Qcm9wZXJ0eVR5cGVzID8/IHt9KS5maWx0ZXIoayA9PiAhKGsgaW4gbmV3UHJvcHNUeXBlcykpO1xuICBpZiAoZGlzYXBwZWFyZWRLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG9wZXJhdGlvbnM6IGFueVtdID0gW107XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgZGlzYXBwZWFyZWRLZXlzKSB7XG4gICAgY29uc3QgW2NmblJlc291cmNlLCB0eXBlTmFtZV0gPSBrZXkuc3BsaXQoJy4nKTtcbiAgICBjb25zdCB1c2FnZXMgPSBmaW5kVHlwZVVzYWdlcyhvbGRTcGVjLCBjZm5SZXNvdXJjZSwgdHlwZU5hbWUpO1xuICAgIGlmICh1c2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBNaWdodCBoYXZlIGRpc2FwcGVhcmVkLCBidXQgbm8gb25lIHNob3VsZCBoYXZlIGJlZW4gdXNpbmcgdGhpc1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgb3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgIG9wOiAnbW92ZScsXG4gICAgICBmcm9tOiBgL1Byb3BlcnR5VHlwZXMvJHtjZm5SZXNvdXJjZX0uPE5FV19UWVBFX05BTUVfSEVSRT5gLFxuICAgICAgcGF0aDogYC9Qcm9wZXJ0eVR5cGVzLyR7Y2ZuUmVzb3VyY2V9LiR7dHlwZU5hbWV9YCxcbiAgICB9KTtcblxuICAgIG9wZXJhdGlvbnMucHVzaCguLi51c2FnZXMubWFwKChwYXRoKSA9PiAoe1xuICAgICAgb3A6ICdyZXBsYWNlJyxcbiAgICAgIHBhdGgsXG4gICAgICB2YWx1ZTogdHlwZU5hbWUsXG4gICAgfSkpKTtcbiAgfVxuXG4gIGNvbnN0IGV4YW1wbGVKc29uUGF0Y2ggPSB7XG4gICAgcGF0Y2g6IHtcbiAgICAgIGRlc2NyaXB0aW9uOiAnVW5kb2luZyB1cHN0cmVhbSBwcm9wZXJ0eSB0eXBlIHJlbmFtZXMgb2YgPFNFUlZJQ0U+IGJlY2F1c2UgPFJFQVNPTj4nLFxuICAgICAgb3BlcmF0aW9ucyxcbiAgICB9LFxuICB9O1xuXG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IFlZWVkgPSBgJHtub3cuZ2V0RnVsbFllYXIoKX1gO1xuICBjb25zdCBNTSA9IGAwJHtub3cuZ2V0TW9udGgoKSArIDF9YC5zbGljZSgtMik7XG4gIGNvbnN0IEREID0gYDAke25vdy5nZXREYXRlKCl9YC5zbGljZSgtMik7XG5cbiAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoW1xuICAgICfilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAnLFxuICAgICfilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilpDilognLFxuICAgICfilIIgIFBST1BFUlRZIFRZUEVTIEhBVkUgRElTQVBQRUFSRUQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilpDilognLFxuICAgICfilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilpDilognLFxuICAgICfilIIgIFNvbWUgdHlwZSBuYW1lcyBoYXZlIGRpc2FwcGVhcmVkIGZyb20gdGhlIG9sZCBzcGVjaWZpY2F0aW9uLiAgICAgICAgICAgICAgICAgICAgICAgICDilpDilognLFxuICAgICfilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilpDilognLFxuICAgICfilIIgIFRoaXMgcHJvYmFibHkgaW5kaWNhdGVzIHRoYXQgdGhlIHNlcnZpY2UgdGVhbSByZW5hbWVkIG9uZSBvZiB0aGUgdHlwZXMuIFdlIGhhdmUgICAgICDilpDilognLFxuICAgICfilIIgIHRvIGtlZXAgdGhlIG9sZCB0eXBlIG5hbWVzIHRob3VnaDogcmVuYW1pbmcgdGhlbSB3b3VsZCBjb25zdGl0dXRlIGEgYnJlYWtpbmcgY2hhbmdlICDilpDilognLFxuICAgICfilIIgIHRvIGNvbnN1bWVycyBvZiB0aGUgTDEgcmVzb3VyY2VzLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilpDilognLFxuICAgICfilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilpDilognLFxuICAgICfilJTilIDiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTiloTilp/ilognLFxuICAgICcnLFxuICAgICdTZWUgd2hhdCB0aGUgcmVuYW1lcyB3ZXJlLCBjaGVjayBvdXQgdGhpcyBQUiBsb2NhbGx5IGFuZCBhZGQgYSBKU09OIHBhdGNoIGZpbGUgZm9yIHRoZXNlIHR5cGVzOicsXG4gICAgJycsXG4gICAgYChFeGFtcGxlIDYwMF9SZW5hbWVzXyR7WVlZWX0ke01NfSR7RER9X3BhdGNoLmpzb24pYCxcbiAgICAnJyxcbiAgICBKU09OLnN0cmluZ2lmeShleGFtcGxlSnNvblBhdGNoLCB1bmRlZmluZWQsIDIpLFxuICAgICdcXG4nLFxuICBdLmpvaW4oJ1xcbicpKTtcbiAgcHJvY2Vzcy5leGl0Q29kZSA9IDE7XG59XG5cbmZ1bmN0aW9uIGZpbmRUeXBlVXNhZ2VzKHNwZWM6IGFueSwgY2ZuUmVzb3VyY2U6IHN0cmluZywgdHlwZU5hbWU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICBjb25zdCB0eXBlc1RvSW5zcGVjdDogQXJyYXk8cmVhZG9ubHkgW3N0cmluZywgc3RyaW5nXT4gPSBbXG4gICAgLi4uT2JqZWN0LmtleXMoc3BlYy5Qcm9wZXJ0eVR5cGVzID8/IHt9KVxuICAgICAgLmZpbHRlcigocHJvcFR5cGVOYW1lKSA9PiBwcm9wVHlwZU5hbWUuc3RhcnRzV2l0aChgJHtjZm5SZXNvdXJjZX0uYCkpXG4gICAgICAubWFwKChwcm9wVHlwZU5hbWUpID0+IFsnUHJvcGVydHlUeXBlcycsIHByb3BUeXBlTmFtZV0gYXMgY29uc3QpLFxuICAgIC4uLnNwZWMuUmVzb3VyY2VUeXBlcz8uW2NmblJlc291cmNlXSA/IFtbJ1Jlc291cmNlVHlwZXMnLCBjZm5SZXNvdXJjZV0gYXMgY29uc3RdIDogW10sXG4gIF07XG5cbiAgZm9yIChjb25zdCBbdG9wS2V5LCB0eXBlS2V5XSBvZiB0eXBlc1RvSW5zcGVjdCkge1xuICAgIGNvbnN0IHByb3BUeXBlID0gc3BlY1t0b3BLZXldW3R5cGVLZXldO1xuXG4gICAgZm9yIChjb25zdCBpbm5lcktleSBvZiBbJ1Byb3BlcnRpZXMnLCAnQXR0cmlidXRlcyddKSB7XG5cbiAgICAgIGZvciAoY29uc3QgW3Byb3BOYW1lLCBwcm9wRGVmXSBvZiBPYmplY3QuZW50cmllcyhwcm9wVHlwZT8uW2lubmVyS2V5XSA/PyB7fSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BEZWYgYXMgYW55KSkge1xuICAgICAgICAgIGlmIChmaWVsZFR5cGUgPT09IHR5cGVOYW1lKSB7XG4gICAgICAgICAgICByZXQucHVzaChgLyR7dG9wS2V5fS8ke3R5cGVLZXl9LyR7aW5uZXJLZXl9LyR7cHJvcE5hbWV9LyR7ZmllbGROYW1lfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59Il19