"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerImageAssetHandler = void 0;
const path = require("path");
const progress_1 = require("../../progress");
const placeholders_1 = require("../placeholders");
const shell_1 = require("../shell");
class ContainerImageAssetHandler {
    constructor(workDir, asset, host) {
        this.workDir = workDir;
        this.asset = asset;
        this.host = host;
    }
    async build() {
        const initOnce = await this.initOnce();
        if (initOnce.destinationAlreadyExists) {
            return;
        }
        if (this.host.aborted) {
            return;
        }
        const dockerForBuilding = await this.host.dockerFactory.forBuild({
            repoUri: initOnce.repoUri,
            logger: (m) => this.host.emitMessage(progress_1.EventType.DEBUG, m),
            ecr: initOnce.ecr,
        });
        const builder = new ContainerImageBuilder(dockerForBuilding, this.workDir, this.asset, this.host);
        const localTagName = await builder.build();
        if (localTagName === undefined || this.host.aborted) {
            return;
        }
        if (this.host.aborted) {
            return;
        }
        await dockerForBuilding.tag(localTagName, initOnce.imageUri);
    }
    async isPublished() {
        try {
            const initOnce = await this.initOnce({ quiet: true });
            return initOnce.destinationAlreadyExists;
        }
        catch (e) {
            this.host.emitMessage(progress_1.EventType.DEBUG, `${e.message}`);
        }
        return false;
    }
    async publish() {
        const initOnce = await this.initOnce();
        if (initOnce.destinationAlreadyExists) {
            return;
        }
        if (this.host.aborted) {
            return;
        }
        const dockerForPushing = await this.host.dockerFactory.forEcrPush({
            repoUri: initOnce.repoUri,
            logger: (m) => this.host.emitMessage(progress_1.EventType.DEBUG, m),
            ecr: initOnce.ecr,
        });
        if (this.host.aborted) {
            return;
        }
        this.host.emitMessage(progress_1.EventType.UPLOAD, `Push ${initOnce.imageUri}`);
        await dockerForPushing.push(initOnce.imageUri);
    }
    async initOnce(options = {}) {
        if (this.init) {
            return this.init;
        }
        const destination = await (0, placeholders_1.replaceAwsPlaceholders)(this.asset.destination, this.host.aws);
        const ecr = await this.host.aws.ecrClient({
            ...destination,
            quiet: options.quiet,
        });
        const account = async () => (await this.host.aws.discoverCurrentAccount())?.accountId;
        const repoUri = await repositoryUri(ecr, destination.repositoryName);
        if (!repoUri) {
            throw new Error(`No ECR repository named '${destination.repositoryName}' in account ${await account()}. Is this account bootstrapped?`);
        }
        const imageUri = `${repoUri}:${destination.imageTag}`;
        this.init = {
            imageUri,
            ecr,
            repoUri,
            destinationAlreadyExists: await this.destinationAlreadyExists(ecr, destination, imageUri),
        };
        return this.init;
    }
    /**
     * Check whether the image already exists in the ECR repo
     *
     * Use the fields from the destination to do the actual check. The imageUri
     * should correspond to that, but is only used to print Docker image location
     * for user benefit (the format is slightly different).
     */
    async destinationAlreadyExists(ecr, destination, imageUri) {
        this.host.emitMessage(progress_1.EventType.CHECK, `Check ${imageUri}`);
        if (await imageExists(ecr, destination.repositoryName, destination.imageTag)) {
            this.host.emitMessage(progress_1.EventType.FOUND, `Found ${imageUri}`);
            return true;
        }
        return false;
    }
}
exports.ContainerImageAssetHandler = ContainerImageAssetHandler;
class ContainerImageBuilder {
    constructor(docker, workDir, asset, host) {
        this.docker = docker;
        this.workDir = workDir;
        this.asset = asset;
        this.host = host;
    }
    async build() {
        return this.asset.source.executable
            ? this.buildExternalAsset(this.asset.source.executable)
            : this.buildDirectoryAsset();
    }
    /**
     * Build a (local) Docker asset from a directory with a Dockerfile
     *
     * Tags under a deterministic, unique, local identifier wich will skip
     * the build if it already exists.
     */
    async buildDirectoryAsset() {
        const localTagName = `cdkasset-${this.asset.id.assetId.toLowerCase()}`;
        if (!(await this.isImageCached(localTagName))) {
            if (this.host.aborted) {
                return undefined;
            }
            await this.buildImage(localTagName);
        }
        return localTagName;
    }
    /**
     * Build a (local) Docker asset by running an external command
     *
     * External command is responsible for deduplicating the build if possible,
     * and is expected to return the generated image identifier on stdout.
     */
    async buildExternalAsset(executable, cwd) {
        const assetPath = cwd ?? this.workDir;
        this.host.emitMessage(progress_1.EventType.BUILD, `Building Docker image using command '${executable}'`);
        if (this.host.aborted) {
            return undefined;
        }
        return (await (0, shell_1.shell)(executable, { cwd: assetPath, quiet: true })).trim();
    }
    async buildImage(localTagName) {
        const source = this.asset.source;
        if (!source.directory) {
            throw new Error(`'directory' is expected in the DockerImage asset source, got: ${JSON.stringify(source)}`);
        }
        const fullPath = path.resolve(this.workDir, source.directory);
        this.host.emitMessage(progress_1.EventType.BUILD, `Building Docker image at ${fullPath}`);
        await this.docker.build({
            directory: fullPath,
            tag: localTagName,
            buildArgs: source.dockerBuildArgs,
            buildSecrets: source.dockerBuildSecrets,
            target: source.dockerBuildTarget,
            file: source.dockerFile,
            networkMode: source.networkMode,
            platform: source.platform,
            outputs: source.dockerOutputs,
            cacheFrom: source.cacheFrom,
            cacheTo: source.cacheTo,
        });
    }
    async isImageCached(localTagName) {
        if (await this.docker.exists(localTagName)) {
            this.host.emitMessage(progress_1.EventType.CACHED, `Cached ${localTagName}`);
            return true;
        }
        return false;
    }
}
async function imageExists(ecr, repositoryName, imageTag) {
    try {
        await ecr.describeImages({ repositoryName, imageIds: [{ imageTag }] }).promise();
        return true;
    }
    catch (e) {
        if (e.code !== 'ImageNotFoundException') {
            throw e;
        }
        return false;
    }
}
/**
 * Return the URI for the repository with the given name
 *
 * Returns undefined if the repository does not exist.
 */
async function repositoryUri(ecr, repositoryName) {
    try {
        const response = await ecr.describeRepositories({ repositoryNames: [repositoryName] }).promise();
        return (response.repositories || [])[0]?.repositoryUri;
    }
    catch (e) {
        if (e.code !== 'RepositoryNotFoundException') {
            throw e;
        }
        return undefined;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGFpbmVyLWltYWdlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvbnRhaW5lci1pbWFnZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNkJBQTZCO0FBSTdCLDZDQUEyQztBQUczQyxrREFBeUQ7QUFDekQsb0NBQWlDO0FBU2pDLE1BQWEsMEJBQTBCO0lBR3JDLFlBQ21CLE9BQWUsRUFDZixLQUErQixFQUMvQixJQUFrQjtRQUZsQixZQUFPLEdBQVAsT0FBTyxDQUFRO1FBQ2YsVUFBSyxHQUFMLEtBQUssQ0FBMEI7UUFDL0IsU0FBSSxHQUFKLElBQUksQ0FBYztJQUNyQyxDQUFDO0lBRU0sS0FBSyxDQUFDLEtBQUs7UUFDaEIsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFdkMsSUFBSSxRQUFRLENBQUMsd0JBQXdCLEVBQUU7WUFBRSxPQUFPO1NBQUU7UUFDbEQsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUFFLE9BQU87U0FBRTtRQUVsQyxNQUFNLGlCQUFpQixHQUFHLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDO1lBQy9ELE9BQU8sRUFBRSxRQUFRLENBQUMsT0FBTztZQUN6QixNQUFNLEVBQUUsQ0FBQyxDQUFTLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLG9CQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUNoRSxHQUFHLEVBQUUsUUFBUSxDQUFDLEdBQUc7U0FDbEIsQ0FBQyxDQUFDO1FBRUgsTUFBTSxPQUFPLEdBQUcsSUFBSSxxQkFBcUIsQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xHLE1BQU0sWUFBWSxHQUFHLE1BQU0sT0FBTyxDQUFDLEtBQUssRUFBRSxD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QUFLLENBQUM7SUFDZixDQUFDO0NBQ0Y7QUFFRCxLQUFLLFVBQVUsV0FBVyxDQUFDLEdBQVksRUFBRSxjQUFzQixFQUFFLFFBQWdCO0lBQy9FLElBQUk7UUFDRixNQUFNLEdBQUcsQ0FBQyxjQUFjLENBQUMsRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNqRixPQUFPLElBQUksQ0FBQztLQUNiO0lBQUMsT0FBTyxDQUFNLEVBQUU7UUFDZixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssd0JBQXdCLEVBQUU7WUFBRSxNQUFNLENBQUMsQ0FBQztTQUFFO1FBQ3JELE9BQU8sS0FBSyxDQUFDO0tBQ2Q7QUFDSCxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILEtBQUssVUFBVSxhQUFhLENBQUMsR0FBWSxFQUFFLGNBQXNCO0lBQy9ELElBQUk7UUFDRixNQUFNLFFBQVEsR0FBRyxNQUFNLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLGVBQWUsRUFBRSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNqRyxPQUFPLENBQUMsUUFBUSxDQUFDLFlBQVksSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxhQUFhLENBQUM7S0FDeEQ7SUFBQyxPQUFPLENBQU0sRUFBRTtRQUNmLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyw2QkFBNkIsRUFBRTtZQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQUU7UUFDMUQsT0FBTyxTQUFTLENBQUM7S0FDbEI7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IERvY2tlckltYWdlRGVzdGluYXRpb24gfSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0IHR5cGUgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBEb2NrZXJJbWFnZU1hbmlmZXN0RW50cnkgfSBmcm9tICcuLi8uLi9hc3NldC1tYW5pZmVzdCc7XG5pbXBvcnQgeyBFdmVudFR5cGUgfSBmcm9tICcuLi8uLi9wcm9ncmVzcyc7XG5pbXBvcnQgeyBJQXNzZXRIYW5kbGVyLCBJSGFuZGxlckhvc3QgfSBmcm9tICcuLi9hc3NldC1oYW5kbGVyJztcbmltcG9ydCB7IERvY2tlciB9IGZyb20gJy4uL2RvY2tlcic7XG5pbXBvcnQgeyByZXBsYWNlQXdzUGxhY2Vob2xkZXJzIH0gZnJvbSAnLi4vcGxhY2Vob2xkZXJzJztcbmltcG9ydCB7IHNoZWxsIH0gZnJvbSAnLi4vc2hlbGwnO1xuXG5pbnRlcmZhY2UgQ29udGFpbmVySW1hZ2VBc3NldEhhbmRsZXJJbml0IHtcbiAgcmVhZG9ubHkgZWNyOiBBV1MuRUNSO1xuICByZWFkb25seSByZXBvVXJpOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGltYWdlVXJpOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGRlc3RpbmF0aW9uQWxyZWFkeUV4aXN0czogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIENvbnRhaW5lckltYWdlQXNzZXRIYW5kbGVyIGltcGxlbWVudHMgSUFzc2V0SGFuZGxlciB7XG4gIHByaXZhdGUgaW5pdD86IENvbnRhaW5lckltYWdlQXNzZXRIYW5kbGVySW5pdDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHdvcmtEaXI6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFzc2V0OiBEb2NrZXJJbWFnZU1hbmlmZXN0RW50cnksXG4gICAgcHJpdmF0ZSByZWFkb25seSBob3N0OiBJSGFuZGxlckhvc3QpIHtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBidWlsZCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBpbml0T25jZSA9IGF3YWl0IHRoaXMuaW5pdE9uY2UoKTtcblxuICAgIGlmIChpbml0T25jZS5kZXN0aW5hdGlvbkFscmVhZHlFeGlzdHMpIHsgcmV0dXJuOyB9XG4gICAgaWYgKHRoaXMuaG9zdC5hYm9ydGVkKSB7IHJldHVybjsgfVxuXG4gICAgY29uc3QgZG9ja2VyRm9yQnVpbGRpbmcgPSBhd2FpdCB0aGlzLmhvc3QuZG9ja2VyRmFjdG9yeS5mb3JCdWlsZCh7XG4gICAgICByZXBvVXJpOiBpbml0T25jZS5yZXBvVXJpLFxuICAgICAgbG9nZ2VyOiAobTogc3RyaW5nKSA9PiB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkRFQlVHLCBtKSxcbiAgICAgIGVjcjogaW5pdE9uY2UuZWNyLFxuICAgIH0pO1xuXG4gICAgY29uc3QgYnVpbGRlciA9IG5ldyBDb250YWluZXJJbWFnZUJ1aWxkZXIoZG9ja2VyRm9yQnVpbGRpbmcsIHRoaXMud29ya0RpciwgdGhpcy5hc3NldCwgdGhpcy5ob3N0KTtcbiAgICBjb25zdCBsb2NhbFRhZ05hbWUgPSBhd2FpdCBidWlsZGVyLmJ1aWxkKCk7XG5cbiAgICBpZiAobG9jYWxUYWdOYW1lID09PSB1bmRlZmluZWQgfHwgdGhpcy5ob3N0LmFib3J0ZWQpIHsgcmV0dXJuOyB9XG4gICAgaWYgKHRoaXMuaG9zdC5hYm9ydGVkKSB7IHJldHVybjsgfVxuXG4gICAgYXdhaXQgZG9ja2VyRm9yQnVpbGRpbmcudGFnKGxvY2FsVGFnTmFtZSwgaW5pdE9uY2UuaW1hZ2VVcmkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGlzUHVibGlzaGVkKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpbml0T25jZSA9IGF3YWl0IHRoaXMuaW5pdE9uY2UoeyBxdWlldDogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiBpbml0T25jZS5kZXN0aW5hdGlvbkFscmVhZHlFeGlzdHM7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkRFQlVHLCBgJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwdWJsaXNoKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGluaXRPbmNlID0gYXdhaXQgdGhpcy5pbml0T25jZSgpO1xuXG4gICAgaWYgKGluaXRPbmNlLmRlc3RpbmF0aW9uQWxyZWFkeUV4aXN0cykgeyByZXR1cm47IH1cbiAgICBpZiAodGhpcy5ob3N0LmFib3J0ZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBkb2NrZXJGb3JQdXNoaW5nID0gYXdhaXQgdGhpcy5ob3N0LmRvY2tlckZhY3RvcnkuZm9yRWNyUHVzaCh7XG4gICAgICByZXBvVXJpOiBpbml0T25jZS5yZXBvVXJpLFxuICAgICAgbG9nZ2VyOiAobTogc3RyaW5nKSA9PiB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkRFQlVHLCBtKSxcbiAgICAgIGVjcjogaW5pdE9uY2UuZWNyLFxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuaG9zdC5hYm9ydGVkKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5VUExPQUQsIGBQdXNoICR7aW5pdE9uY2UuaW1hZ2VVcml9YCk7XG4gICAgYXdhaXQgZG9ja2VyRm9yUHVzaGluZy5wdXNoKGluaXRPbmNlLmltYWdlVXJpKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdE9uY2Uob3B0aW9uczogeyBxdWlldD86IGJvb2xlYW4gfSA9IHt9KTogUHJvbWlzZTxDb250YWluZXJJbWFnZUFzc2V0SGFuZGxlckluaXQ+IHtcbiAgICBpZiAodGhpcy5pbml0KSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0O1xuICAgIH1cblxuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gYXdhaXQgcmVwbGFjZUF3c1BsYWNlaG9sZGVycyh0aGlzLmFzc2V0LmRlc3RpbmF0aW9uLCB0aGlzLmhvc3QuYXdzKTtcbiAgICBjb25zdCBlY3IgPSBhd2FpdCB0aGlzLmhvc3QuYXdzLmVjckNsaWVudCh7XG4gICAgICAuLi5kZXN0aW5hdGlvbixcbiAgICAgIHF1aWV0OiBvcHRpb25zLnF1aWV0LFxuICAgIH0pO1xuICAgIGNvbnN0IGFjY291bnQgPSBhc3luYyAoKSA9PiAoYXdhaXQgdGhpcy5ob3N0LmF3cy5kaXNjb3ZlckN1cnJlbnRBY2NvdW50KCkpPy5hY2NvdW50SWQ7XG5cbiAgICBjb25zdCByZXBvVXJpID0gYXdhaXQgcmVwb3NpdG9yeVVyaShlY3IsIGRlc3RpbmF0aW9uLnJlcG9zaXRvcnlOYW1lKTtcbiAgICBpZiAoIXJlcG9VcmkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gRUNSIHJlcG9zaXRvcnkgbmFtZWQgJyR7ZGVzdGluYXRpb24ucmVwb3NpdG9yeU5hbWV9JyBpbiBhY2NvdW50ICR7YXdhaXQgYWNjb3VudCgpfS4gSXMgdGhpcyBhY2NvdW50IGJvb3RzdHJhcHBlZD9gKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbWFnZVVyaSA9IGAke3JlcG9Vcml9OiR7ZGVzdGluYXRpb24uaW1hZ2VUYWd9YDtcblxuICAgIHRoaXMuaW5pdCA9IHtcbiAgICAgIGltYWdlVXJpLFxuICAgICAgZWNyLFxuICAgICAgcmVwb1VyaSxcbiAgICAgIGRlc3RpbmF0aW9uQWxyZWFkeUV4aXN0czogYXdhaXQgdGhpcy5kZXN0aW5hdGlvbkFscmVhZHlFeGlzdHMoZWNyLCBkZXN0aW5hdGlvbiwgaW1hZ2VVcmkpLFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5pbml0O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGltYWdlIGFscmVhZHkgZXhpc3RzIGluIHRoZSBFQ1IgcmVwb1xuICAgKlxuICAgKiBVc2UgdGhlIGZpZWxkcyBmcm9tIHRoZSBkZXN0aW5hdGlvbiB0byBkbyB0aGUgYWN0dWFsIGNoZWNrLiBUaGUgaW1hZ2VVcmlcbiAgICogc2hvdWxkIGNvcnJlc3BvbmQgdG8gdGhhdCwgYnV0IGlzIG9ubHkgdXNlZCB0byBwcmludCBEb2NrZXIgaW1hZ2UgbG9jYXRpb25cbiAgICogZm9yIHVzZXIgYmVuZWZpdCAodGhlIGZvcm1hdCBpcyBzbGlnaHRseSBkaWZmZXJlbnQpLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBkZXN0aW5hdGlvbkFscmVhZHlFeGlzdHMoZWNyOiBBV1MuRUNSLCBkZXN0aW5hdGlvbjogRG9ja2VySW1hZ2VEZXN0aW5hdGlvbiwgaW1hZ2VVcmk6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQ0hFQ0ssIGBDaGVjayAke2ltYWdlVXJpfWApO1xuICAgIGlmIChhd2FpdCBpbWFnZUV4aXN0cyhlY3IsIGRlc3RpbmF0aW9uLnJlcG9zaXRvcnlOYW1lLCBkZXN0aW5hdGlvbi5pbWFnZVRhZykpIHtcbiAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuRk9VTkQsIGBGb3VuZCAke2ltYWdlVXJpfWApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmNsYXNzIENvbnRhaW5lckltYWdlQnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZG9ja2VyOiBEb2NrZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSB3b3JrRGlyOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBhc3NldDogRG9ja2VySW1hZ2VNYW5pZmVzdEVudHJ5LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgaG9zdDogSUhhbmRsZXJIb3N0KSB7XG4gIH1cblxuICBhc3luYyBidWlsZCgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiB0aGlzLmFzc2V0LnNvdXJjZS5leGVjdXRhYmxlXG4gICAgICA/IHRoaXMuYnVpbGRFeHRlcm5hbEFzc2V0KHRoaXMuYXNzZXQuc291cmNlLmV4ZWN1dGFibGUpXG4gICAgICA6IHRoaXMuYnVpbGREaXJlY3RvcnlBc3NldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEgKGxvY2FsKSBEb2NrZXIgYXNzZXQgZnJvbSBhIGRpcmVjdG9yeSB3aXRoIGEgRG9ja2VyZmlsZVxuICAgKlxuICAgKiBUYWdzIHVuZGVyIGEgZGV0ZXJtaW5pc3RpYywgdW5pcXVlLCBsb2NhbCBpZGVudGlmaWVyIHdpY2ggd2lsbCBza2lwXG4gICAqIHRoZSBidWlsZCBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgYnVpbGREaXJlY3RvcnlBc3NldCgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IGxvY2FsVGFnTmFtZSA9IGBjZGthc3NldC0ke3RoaXMuYXNzZXQuaWQuYXNzZXRJZC50b0xvd2VyQ2FzZSgpfWA7XG5cbiAgICBpZiAoIShhd2FpdCB0aGlzLmlzSW1hZ2VDYWNoZWQobG9jYWxUYWdOYW1lKSkpIHtcbiAgICAgIGlmICh0aGlzLmhvc3QuYWJvcnRlZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICAgIGF3YWl0IHRoaXMuYnVpbGRJbWFnZShsb2NhbFRhZ05hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBsb2NhbFRhZ05hbWU7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYSAobG9jYWwpIERvY2tlciBhc3NldCBieSBydW5uaW5nIGFuIGV4dGVybmFsIGNvbW1hbmRcbiAgICpcbiAgICogRXh0ZXJuYWwgY29tbWFuZCBpcyByZXNwb25zaWJsZSBmb3IgZGVkdXBsaWNhdGluZyB0aGUgYnVpbGQgaWYgcG9zc2libGUsXG4gICAqIGFuZCBpcyBleHBlY3RlZCB0byByZXR1cm4gdGhlIGdlbmVyYXRlZCBpbWFnZSBpZGVudGlmaWVyIG9uIHN0ZG91dC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgYnVpbGRFeHRlcm5hbEFzc2V0KGV4ZWN1dGFibGU6IHN0cmluZ1tdLCBjd2Q/OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IGFzc2V0UGF0aCA9IGN3ZCA/PyB0aGlzLndvcmtEaXI7XG5cbiAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkJVSUxELCBgQnVpbGRpbmcgRG9ja2VyIGltYWdlIHVzaW5nIGNvbW1hbmQgJyR7ZXhlY3V0YWJsZX0nYCk7XG4gICAgaWYgKHRoaXMuaG9zdC5hYm9ydGVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICAgIHJldHVybiAoYXdhaXQgc2hlbGwoZXhlY3V0YWJsZSwgeyBjd2Q6IGFzc2V0UGF0aCwgcXVpZXQ6IHRydWUgfSkpLnRyaW0oKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgYnVpbGRJbWFnZShsb2NhbFRhZ05hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuYXNzZXQuc291cmNlO1xuICAgIGlmICghc291cmNlLmRpcmVjdG9yeSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAnZGlyZWN0b3J5JyBpcyBleHBlY3RlZCBpbiB0aGUgRG9ja2VySW1hZ2UgYXNzZXQgc291cmNlLCBnb3Q6ICR7SlNPTi5zdHJpbmdpZnkoc291cmNlKX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLndvcmtEaXIsIHNvdXJjZS5kaXJlY3RvcnkpO1xuICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQlVJTEQsIGBCdWlsZGluZyBEb2NrZXIgaW1hZ2UgYXQgJHtmdWxsUGF0aH1gKTtcblxuICAgIGF3YWl0IHRoaXMuZG9ja2VyLmJ1aWxkKHtcbiAgICAgIGRpcmVjdG9yeTogZnVsbFBhdGgsXG4gICAgICB0YWc6IGxvY2FsVGFnTmFtZSxcbiAgICAgIGJ1aWxkQXJnczogc291cmNlLmRvY2tlckJ1aWxkQXJncyxcbiAgICAgIGJ1aWxkU2VjcmV0czogc291cmNlLmRvY2tlckJ1aWxkU2VjcmV0cyxcbiAgICAgIHRhcmdldDogc291cmNlLmRvY2tlckJ1aWxkVGFyZ2V0LFxuICAgICAgZmlsZTogc291cmNlLmRvY2tlckZpbGUsXG4gICAgICBuZXR3b3JrTW9kZTogc291cmNlLm5ldHdvcmtNb2RlLFxuICAgICAgcGxhdGZvcm06IHNvdXJjZS5wbGF0Zm9ybSxcbiAgICAgIG91dHB1dHM6IHNvdXJjZS5kb2NrZXJPdXRwdXRzLFxuICAgICAgY2FjaGVGcm9tOiBzb3VyY2UuY2FjaGVGcm9tLFxuICAgICAgY2FjaGVUbzogc291cmNlLmNhY2hlVG8sXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGlzSW1hZ2VDYWNoZWQobG9jYWxUYWdOYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoYXdhaXQgdGhpcy5kb2NrZXIuZXhpc3RzKGxvY2FsVGFnTmFtZSkpIHtcbiAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQ0FDSEVELCBgQ2FjaGVkICR7bG9jYWxUYWdOYW1lfWApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGltYWdlRXhpc3RzKGVjcjogQVdTLkVDUiwgcmVwb3NpdG9yeU5hbWU6IHN0cmluZywgaW1hZ2VUYWc6IHN0cmluZykge1xuICB0cnkge1xuICAgIGF3YWl0IGVjci5kZXNjcmliZUltYWdlcyh7IHJlcG9zaXRvcnlOYW1lLCBpbWFnZUlkczogW3sgaW1hZ2VUYWcgfV0gfSkucHJvbWlzZSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICBpZiAoZS5jb2RlICE9PSAnSW1hZ2VOb3RGb3VuZEV4Y2VwdGlvbicpIHsgdGhyb3cgZTsgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgVVJJIGZvciB0aGUgcmVwb3NpdG9yeSB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gKlxuICogUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIHJlcG9zaXRvcnkgZG9lcyBub3QgZXhpc3QuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlcG9zaXRvcnlVcmkoZWNyOiBBV1MuRUNSLCByZXBvc2l0b3J5TmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVjci5kZXNjcmliZVJlcG9zaXRvcmllcyh7IHJlcG9zaXRvcnlOYW1lczogW3JlcG9zaXRvcnlOYW1lXSB9KS5wcm9taXNlKCk7XG4gICAgcmV0dXJuIChyZXNwb25zZS5yZXBvc2l0b3JpZXMgfHwgW10pWzBdPy5yZXBvc2l0b3J5VXJpO1xuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICBpZiAoZS5jb2RlICE9PSAnUmVwb3NpdG9yeU5vdEZvdW5kRXhjZXB0aW9uJykgeyB0aHJvdyBlOyB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuIl19